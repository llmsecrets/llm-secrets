import * as React from 'react';
import { useState, useEffect, useCallback, useMemo } from 'react';

type DecryptMethod = 'windowsHello' | 'manualKey';
type ViewState = 'encrypted' | 'decrypted' | 'justSaved';
type AuthStep = 'selectMethod' | 'enterKeepassPassword' | 'authenticating';
type SecurityMode = 'simple' | 'advanced';

interface SecretManagerProps {
  onEditingChange?: (isEditing: boolean) => void;
}

// Parse secret names from .env content
const parseSecretNames = (content: string): string[] => {
  return content.split('\n')
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#') && line.includes('='))
    .map(line => line.split('=')[0].trim())
    .filter(Boolean);
};

// Generate CLAUDE.md preview content (simplified version for preview)
const generateClaudeMdPreview = (secretNames: string[]): string => {
  const secretsTable = secretNames.length > 0
    ? secretNames.map(name => `| ${name} | User-defined | \`$env:${name}\` |`).join('\n')
    : '| (No secrets added yet) | - | - |';

  return `# LLM Secrets - Secret Access Reference

## Stored Secrets

| Name | Purpose | Access Via |
|------|---------|------------|
${secretsTable}

## How to Run Commands with Secrets

Write commands using \`$env:SECRET_NAME\` syntax.
LLM Secrets injects the actual values at runtime.

### Examples

\`\`\`powershell
forge script script/Deploy.s.sol --private-key $env:PRIVATE_KEY
curl -H "Authorization: Bearer $env:API_KEY" https://api.example.com
\`\`\`

---
*Generated by LLM Secrets*`;
};

export const SecretManager: React.FC<SecretManagerProps> = ({ onEditingChange }) => {
  const [viewState, setViewState] = useState<ViewState>('encrypted');
  const [content, setContent] = useState('');
  const [masterKey, setMasterKey] = useState('');
  const [storedMasterKey, setStoredMasterKey] = useState<string | null>(null);
  const [keepassPassword, setKeepassPassword] = useState('');
  const [showDecryptDialog, setShowDecryptDialog] = useState(false);
  const [decryptMethod, setDecryptMethod] = useState<DecryptMethod>('windowsHello');
  const [authStep, setAuthStep] = useState<AuthStep>('selectMethod');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [lastSaveTime, setLastSaveTime] = useState<string>('');
  const [securityMode, setSecurityMode] = useState<SecurityMode>('simple');
  const [claudeMdPath, setClaudeMdPath] = useState<string | null>(null);

  // Drag-drop state
  const [isDragging, setIsDragging] = useState(false);

  // Preview panel states
  const [showSecretPreview, setShowSecretPreview] = useState(true);
  const [showClaudeMdPreview, setShowClaudeMdPreview] = useState(false);

  // Memoized secret names from content
  const secretNames = useMemo(() => parseSecretNames(content), [content]);

  // Memoized CLAUDE.md preview
  const claudeMdPreview = useMemo(() => generateClaudeMdPreview(secretNames), [secretNames]);

  // Load security mode on mount
  useEffect(() => {
    loadSecurityMode();
  }, []);

  // Notify parent when editing state changes
  useEffect(() => {
    if (onEditingChange) {
      onEditingChange(viewState === 'decrypted');
    }
  }, [viewState, onEditingChange]);

  const loadSecurityMode = async () => {
    try {
      const result = await window.electronAPI.getSimpleSecretSettings();
      if (result.success && result.data) {
        setSecurityMode(result.data.securityMode || 'simple');
      }
    } catch (err) {
      console.error('Failed to load security mode:', err);
    }
  };

  // Drag-drop handlers
  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  const handleDragEnter = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    // Only set isDragging to false if we're leaving the drop zone entirely
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX;
    const y = e.clientY;
    if (x < rect.left || x >= rect.right || y < rect.top || y >= rect.bottom) {
      setIsDragging(false);
    }
  }, []);

  const handleDrop = useCallback(async (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    const envFiles = files.filter(file =>
      file.name.endsWith('.env') ||
      file.name.startsWith('.env') ||
      file.name.includes('.env.')
    );

    if (envFiles.length === 0) {
      // Accept any text file for flexibility
      const textFiles = files.filter(file =>
        file.type === 'text/plain' ||
        file.name.endsWith('.txt') ||
        !file.type // No type = likely text file
      );
      if (textFiles.length === 0) {
        setError('Please drop .env or text files');
        return;
      }
      envFiles.push(...textFiles);
    }

    try {
      const fileContents = await Promise.all(
        envFiles.map(file => file.text())
      );

      // Append each file's content with a comment header
      const newContent = fileContents.map((text, i) => {
        const fileName = envFiles[i].name;
        return `\n# === Imported from ${fileName} ===\n${text.trim()}`;
      }).join('\n');

      setContent(prev => {
        const trimmed = prev.trim();
        return trimmed ? `${trimmed}\n${newContent}` : newContent.trim();
      });
      setError('');
    } catch (err) {
      setError(`Failed to read file: ${(err as Error).message}`);
    }
  }, []);

  const handleDecrypt = () => {
    setShowDecryptDialog(true);
    setDecryptMethod('windowsHello');
    setAuthStep('selectMethod');
    setKeepassPassword('');
    setError('');
  };

  const performDecrypt = async () => {
    await window.electronAPI.debugLog('SecretManager', 'performDecrypt START', {
      decryptMethod,
      securityMode,
      masterKeyLength: masterKey?.length || 0
    });

    // If using manual key, validate it
    if (decryptMethod === 'manualKey' && (!masterKey || masterKey.length !== 44)) {
      setError('Master key must be exactly 44 characters');
      return;
    }

    setLoading(true);
    setError('');

    let retrievedMasterKey = '';

    try {
      if (decryptMethod === 'windowsHello') {
        if (securityMode === 'simple') {
          // Simple mode: Windows Hello only - returns master key
          await window.electronAPI.debugLog('SecretManager', 'Simple mode - calling authenticateSimple...');
          setAuthStep('authenticating');
          const authResult = await window.electronAPI.authenticateSimple();

          await window.electronAPI.debugLog('SecretManager', 'authenticateSimple returned', {
            success: authResult.success,
            hasMasterKey: !!authResult.masterKey,
            masterKeyLength: authResult.masterKey?.length || 0,
            error: authResult.error || null
          });

          if (!authResult.success) {
            setError(authResult.error || 'Windows Hello authentication failed');
            setAuthStep('selectMethod');
            setLoading(false);
            return;
          }
          // Get master key from authentication result
          retrievedMasterKey = authResult.masterKey || '';
          await window.electronAPI.debugLog('SecretManager', 'Retrieved master key from authResult', {
            retrievedKeyLength: retrievedMasterKey.length,
            retrievedKeyPreview: retrievedMasterKey ? retrievedMasterKey.substring(0, 10) + '...' : 'EMPTY'
          });
        } else {
          // Advanced mode: Check for active session
          await window.electronAPI.debugLog('SecretManager', 'Advanced mode - checking session...');
          const sessionCheck = await window.electronAPI.checkSession();
          if (!sessionCheck.hasSession) {
            setAuthStep('enterKeepassPassword');
            setLoading(false);
            return;
          }
        }
      }

      // For Simple mode: use retrieved master key from DPAPI
      // For Advanced mode with session: pass empty string (backend retrieves from KeePass)
      // For manual key: use the manually entered key
      const keyToUse = decryptMethod === 'manualKey' ? masterKey : retrievedMasterKey;

      await window.electronAPI.debugLog('SecretManager', 'Calling decryptEnv', {
        keyToUseLength: keyToUse?.length || 0,
        keyToUseProvided: !!keyToUse && keyToUse.trim() !== '',
        keyToUsePreview: keyToUse ? keyToUse.substring(0, 10) + '...' : 'EMPTY'
      });

      const result = await window.electronAPI.decryptEnv(keyToUse);

      await window.electronAPI.debugLog('SecretManager', 'decryptEnv returned', {
        success: result.success,
        dataLength: result.data?.length || 0,
        error: result.error || null
      });

      if (result.success && result.data) {
        setContent(result.data);
        setViewState('decrypted');
        setShowDecryptDialog(false);
        setMasterKey('');
        setKeepassPassword('');
        setAuthStep('selectMethod');
        await window.electronAPI.debugLog('SecretManager', 'Decryption SUCCESS');
      } else {
        setError(result.error || 'Decryption failed');
        setAuthStep('selectMethod');
        await window.electronAPI.debugLog('SecretManager', 'Decryption FAILED', { error: result.error });
      }
    } catch (err) {
      const errorMsg = (err as Error).message;
      await window.electronAPI.debugLog('SecretManager', 'EXCEPTION in performDecrypt', { error: errorMsg });
      setError(`Error: ${errorMsg}`);
      setAuthStep('selectMethod');
    } finally {
      setLoading(false);
    }
  };

  const performAuthentication = async () => {
    if (!keepassPassword) {
      setError('Please enter your KeePass password');
      return;
    }

    setAuthStep('authenticating');
    setLoading(true);
    setError('');

    try {
      // Create session (this will trigger Windows Hello + verify KeePass password)
      const result = await window.electronAPI.createSession(keepassPassword);

      if (result.success) {
        // Session created, now perform the actual decrypt
        setKeepassPassword(''); // Clear password from memory
        await performDecrypt();
      } else {
        setError(result.error || 'Authentication failed');
        setAuthStep('enterKeepassPassword');
      }
    } catch (err) {
      setError(`Error: ${(err as Error).message}`);
      setAuthStep('enterKeepassPassword');
    } finally {
      setLoading(false);
    }
  };

  const handleEncrypt = async () => {
    if (!content.trim()) {
      setError('Content cannot be empty');
      return;
    }

    setLoading(true);
    setError('');

    try {
      // Use empty string for encryption (backend will retrieve master key based on mode)
      const result = await window.electronAPI.encryptEnv(content, '');
      if (result.success) {
        // Extract secret names and regenerate CLAUDE.md
        const names = parseSecretNames(content);
        let generatedClaudeMdPath: string | null = null;
        if (names.length > 0) {
          const claudeResult = await window.electronAPI.generateClaudeMd(names);
          if (claudeResult.success && claudeResult.path) {
            generatedClaudeMdPath = claudeResult.path;
            // Add to Claude's whitelist
            await window.electronAPI.addClaudeWhitelist();
          }
        }

        setContent('');
        setMasterKey('');
        setClaudeMdPath(generatedClaudeMdPath);
        setLastSaveTime(new Date().toLocaleTimeString());
        setViewState('justSaved');
      } else {
        setError(result.error || 'Encryption failed');
      }
    } catch (err) {
      setError(`Error: ${(err as Error).message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleDiscard = () => {
    setContent('');
    setViewState('encrypted');
    setMasterKey('');
    setError('');
  };

  const handleDone = () => {
    setViewState('encrypted');
    setError('');
  };

  // Get mode-specific text
  const getAuthDescription = () => {
    if (securityMode === 'simple') {
      return "You'll authenticate with Windows Hello (PIN or fingerprint).";
    }
    return "You'll authenticate with Windows Hello and your KeePass password.";
  };

  const getInfoSteps = () => {
    if (securityMode === 'simple') {
      return [
        'Click the decrypt button when you need to view or edit your secrets',
        'Authenticate with Windows Hello (PIN or fingerprint)',
        'Make your changes in the editor - your secrets stay in memory, never written to disk',
        'Save and encrypt to lock everything back up. Claude Code can use your secrets without ever seeing them'
      ];
    }
    return [
      'Click the decrypt button when you need to view or edit your secrets',
      'Authenticate with Windows Hello (PIN or fingerprint) and your KeePass password',
      'Make your changes in the editor - your secrets stay in memory, never written to disk',
      'Save and encrypt to lock everything back up. Claude Code can use your secrets without ever seeing them'
    ];
  };

  return (
    <div className="secret-manager">
      <div className="card">
        <h2>Secret Manager</h2>
        <div className={`status-badge ${viewState === 'decrypted' ? 'warning' : 'success'}`}>
          {viewState === 'decrypted' ? 'DECRYPTED' : viewState === 'justSaved' ? 'SAVED' : 'ENCRYPTED'}
        </div>

        {viewState === 'encrypted' && (
          <div className="decrypt-section">
            <p>Your secrets are safely encrypted and protected.</p>
            <p style={{ fontSize: '14px', color: 'var(--text-secondary)', marginTop: '0.5rem', marginBottom: '1rem' }}>
              Click below to <strong>view, add, edit, or delete</strong> your secrets.
            </p>
            <button className="btn-primary" onClick={handleDecrypt} disabled={loading}>
              Unlock Secrets Manager
            </button>
            <p style={{ fontSize: '13px', color: 'var(--text-secondary)', marginTop: '1rem' }}>
              {getAuthDescription()}
            </p>
          </div>
        )}

        {viewState === 'decrypted' && (
          <div className="editor-section">
            <div className="warning-banner">
              Your secrets are temporarily visible in memory. Remember to encrypt and save when you're done.
            </div>

            <div
              className={`drop-zone ${isDragging ? 'drag-active' : ''}`}
              onDragOver={handleDragOver}
              onDragEnter={handleDragEnter}
              onDragLeave={handleDragLeave}
              onDrop={handleDrop}
            >
              <textarea
                className="code-editor env-droppable"
                value={content}
                onChange={(e) => setContent(e.target.value)}
                placeholder="# Your environment variables
API_KEY=your_api_key_here
DATABASE_URL=postgresql://...
STRIPE_KEY=sk_live_..."
                rows={15}
              />
              <div className="drop-zone-hint">
                Drag and drop .env files here to import, or type above
              </div>
            </div>

            {/* Secret Preview Panel */}
            {secretNames.length > 0 && (
              <div className="secret-preview-panel">
                <div
                  className="secret-preview-header"
                  onClick={() => setShowSecretPreview(!showSecretPreview)}
                >
                  <span>Detected Secrets ({secretNames.length})</span>
                  <span className="toggle-icon">{showSecretPreview ? '▼' : '▶'}</span>
                </div>
                {showSecretPreview && (
                  <div className="secret-list">
                    {secretNames.map((name, i) => (
                      <div key={i} className="secret-item">
                        <span className="secret-name">{name}</span>
                        <span className="secret-value-masked">••••••</span>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}

            {/* CLAUDE.md Preview Panel */}
            {secretNames.length > 0 && (
              <div className="secret-preview-panel">
                <div
                  className="secret-preview-header"
                  onClick={() => setShowClaudeMdPreview(!showClaudeMdPreview)}
                >
                  <span>CLAUDE.md Preview</span>
                  <span className="toggle-icon">{showClaudeMdPreview ? '▼' : '▶'}</span>
                </div>
                {showClaudeMdPreview && (
                  <div className="claude-md-preview">
                    {claudeMdPreview}
                  </div>
                )}
              </div>
            )}

            <div className="button-group">
              <button className="btn-primary" onClick={handleEncrypt} disabled={loading}>
                {loading ? 'Encrypting your secrets...' : 'Save and Encrypt'}
              </button>
              <button className="btn-danger" onClick={handleDiscard} disabled={loading}>
                Discard Changes
              </button>
            </div>
          </div>
        )}

        {viewState === 'justSaved' && (
          <div className="success-section">
            <div className="result-card success">
              <h3>Your Secrets Are Safe</h3>
              <p>Everything has been encrypted and saved successfully.</p>
              <div className="saved-files">
                <div className="saved-file-item">
                  <span className="file-label">Encrypted secrets:</span>
                  <code>C:\Users\jgott\OneDrive\Desktop\Keep Scrt\.env.encrypted</code>
                </div>
                {claudeMdPath && (
                  <div className="saved-file-item">
                    <span className="file-label">Claude reference:</span>
                    <code>{claudeMdPath}</code>
                  </div>
                )}
              </div>
              <p className="save-time">Saved at {lastSaveTime}</p>
            </div>

            <div className="button-group">
              <button className="btn-primary" onClick={handleDecrypt}>
                Edit Again
              </button>
              <button className="btn-secondary" onClick={handleDone}>
                Done
              </button>
            </div>
          </div>
        )}

        {error && <div className="error-message">{error}</div>}

        {showDecryptDialog && (
          <div className="modal-overlay" onClick={() => !loading && setShowDecryptDialog(false)}>
            <div className="modal" onClick={(e) => e.stopPropagation()}>
              {authStep === 'selectMethod' && (
                <>
                  <h3>Choose How to Unlock Your Secrets</h3>

                  <div className="decrypt-method-selector">
                    <label className={`method-option ${decryptMethod === 'windowsHello' ? 'selected' : ''}`}>
                      <input
                        type="radio"
                        name="decryptMethod"
                        checked={decryptMethod === 'windowsHello'}
                        onChange={() => setDecryptMethod('windowsHello')}
                      />
                      <div className="method-content">
                        <strong>
                          {securityMode === 'simple' ? 'Windows Hello' : 'Windows Hello + KeePass'}
                        </strong>
                        <span className="method-desc">
                          {securityMode === 'simple'
                            ? 'Use your PIN or fingerprint'
                            : 'Use your PIN or fingerprint (Recommended)'}
                        </span>
                      </div>
                    </label>

                    <label className={`method-option ${decryptMethod === 'manualKey' ? 'selected' : ''}`}>
                      <input
                        type="radio"
                        name="decryptMethod"
                        checked={decryptMethod === 'manualKey'}
                        onChange={() => setDecryptMethod('manualKey')}
                      />
                      <div className="method-content">
                        <strong>Backup Master Key</strong>
                        <span className="method-desc">Use your 44-character recovery key</span>
                      </div>
                    </label>
                  </div>

                  {decryptMethod === 'manualKey' && (
                    <input
                      type="password"
                      className="master-key-input"
                      value={masterKey}
                      onChange={(e) => setMasterKey(e.target.value)}
                      placeholder="Paste your 44-character master key here"
                      maxLength={44}
                      autoFocus
                      onKeyPress={(e) => e.key === 'Enter' && performDecrypt()}
                    />
                  )}

                  {decryptMethod === 'windowsHello' && (
                    <p className="info-text">
                      {securityMode === 'simple'
                        ? "You'll be prompted for your Windows Hello PIN or fingerprint."
                        : "You'll be prompted for your Windows Hello PIN and KeePass password."}
                    </p>
                  )}

                  <div className="button-group">
                    <button className="btn-primary" onClick={performDecrypt} disabled={loading}>
                      {loading ? 'Checking...' : 'Continue'}
                    </button>
                    <button className="btn-secondary" onClick={() => setShowDecryptDialog(false)} disabled={loading}>
                      Cancel
                    </button>
                  </div>
                </>
              )}

              {authStep === 'enterKeepassPassword' && (
                <>
                  <h3>Enter Your KeePass Password</h3>
                  <p className="info-text">
                    Next, you'll be asked for your Windows Hello PIN or fingerprint.
                  </p>

                  <input
                    type="password"
                    className="master-key-input"
                    value={keepassPassword}
                    onChange={(e) => setKeepassPassword(e.target.value)}
                    placeholder="Your KeePass password"
                    autoFocus
                    onKeyPress={(e) => e.key === 'Enter' && performAuthentication()}
                  />

                  <div className="button-group">
                    <button className="btn-primary" onClick={performAuthentication} disabled={loading}>
                      {loading ? 'Verifying...' : 'Continue'}
                    </button>
                    <button className="btn-secondary" onClick={() => setAuthStep('selectMethod')} disabled={loading}>
                      Back
                    </button>
                  </div>
                </>
              )}

              {authStep === 'authenticating' && (
                <>
                  <h3>Verifying Your Identity</h3>
                  <p className="info-text">
                    Please complete the Windows Hello prompt to continue.
                  </p>
                  <div className="loading-spinner">Waiting for authentication...</div>
                  <div className="button-group" style={{ marginTop: '1.5rem' }}>
                    <button
                      className="btn-secondary"
                      onClick={() => {
                        setLoading(false);
                        setAuthStep('selectMethod');
                        setError('');
                      }}
                    >
                      Cancel
                    </button>
                  </div>
                </>
              )}

              {error && <div className="error-message">{error}</div>}
            </div>
          </div>
        )}

        <div className="info-section">
          <h3>How LLM Secrets keeps you safe</h3>
          <ol>
            {getInfoSteps().map((step, index) => (
              <li key={index}>{step}</li>
            ))}
          </ol>
        </div>
      </div>
    </div>
  );
};
